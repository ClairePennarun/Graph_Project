\documentclass[12pt]{article}
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\addtolength{\hoffset}{-1cm}
\addtolength{\textwidth}{2cm} 
\addtolength{\voffset}{-1cm}
\addtolength{\textheight}{2cm} 

\begin{document}

\begin{titlepage}
\begin{center}

\hfill
\vfill
\bigskip
\huge{Rapport de projet} 
\vfill
\bigskip 
\Huge 
\bigskip Implémentation de méthodes heuristiques pour le partitionnement de graphes \par 
\vfill
\Large Paul-Emile Boutoille \par
		Claire Pennarun \par 
		Tatiana Rocher
\vfill
\Large Bordeaux 1 \par \Large Graphes et Recherche Opérationnelle		
		\bigskip 
\bigskip

\Large
8 janvier 2013
\end{center}
\end{titlepage}

\tableofcontents
\newpage

% A COMPLETER : tableaux / conclusions recuit

\part{Présentation du programme}

\section{But}

Ce programme permet d’utiliser différents algorithmes d’heuristique pour la résolution d’un problème de partitionnement d’un graphe en un nombre donné de classes de sommets. Ce programme permet ainsi de faire des tests de rapidité et de comparer la vitesse des algorithmes en fonction du nombre de sommets du graphe et du nombre de classes.

\section{Mode d'emploi du programme}

Le programme doit être utilisé sur des fichiers de la forme suivante :

\# nbSommets nbAretes

4 4

\# dmin dmax

1 3

\# source but valeur

1 2 1

1 3 1

2 3 1

3 4 1

\# sommet degre

1 2

2 2

3 3

4 1

La dernière partie du fichier (qui donne les degrés de chaque sommet) n’est pas nécessaire car elle n’est pas utilisée par notre programme.
\bigskip

Notre programme se lance avec les arguments suivants :

   $<$fichier$>$ $<$algorithme$>$ $<$nbClasse$>$ $<$nbLancements$>$ $<$option1$>$ $<$option2$>$

\bigskip
   Les deux derniers arguments ne sont nécessaires que dans certains cas, mais ne font pas planter le programme si ils sont présents.

	\begin{itemize}
   \item $<$fichier$>$ représente le fichier sur lequel on veut lancer le programme, chaque fichier représentant un graphe.

  \item  $<$algorithme$>$ représente l'algorithme que l'on veut utiliser : "ex" pour l'algorithme d'exhaustion, "grad" pour l'algorithme de descente de gradient, "recuit" pour l'algorithme du recuit simulé, “tabou” pour l’algorithme tabou.

   \item $<$nbClasse$>$ représente le nombre de classes de sommets voulu.

	\item $<$nbLancements$>$ représente le nombre de lancements voulus de l'algorithme choisi (avec les mêmes paramètres).

   \item $<$option1$>$ représente le voisinage que l’on veut utiliser : “PnD” pour le voisinage Pick and Drop, “Swap” pour le voisinage swap. Cet argument n’est pas nécessaire pour lancer l’algorithme exhaustif mais obligatoire pour les autres.

   \item $<$option2$>$ Est lié à l’algorithme :
		\begin{itemize}
		\item pour l’algorithme du Recuit Simulé, $<$option2$>$ est la température initiale (c’est un double)
		\item pour l’algorithme Tabou, cet argument est la taille du tableau des mouvements tabous (int supérieur à 0).
    	\item pour les autres algorithmes, cet argument est inutile.
    	\end{itemize}
	\end{itemize}
	
\newpage	
	
\part{Choix généraux}
\setcounter{section}{0}
\section{Choix des algorithmes implémentés}
Nous avons implémenté quatre algorithmes :
	\begin{itemize}
    \item Algorithme exhaustif
    \item Algorithme avec descente de gradient
	\item Algorithme de recuit simulé
	\item Algorithme Tabou
	\end{itemize}
Les trois premiers algorithmes étaient obligatoires, et nous avons choisi comme quatrième algorithme l’algorithme Tabou, car la gestion d’un tableau de mouvements interdits nous paraissait intéressante.
Les trois derniers algorithmes sont lancés plusieurs fois sur plusieurs solutions initiales. Nous détaillons plus loin cette fonctionnalité.

\section{Langage de programmation}
    Nous avons choisi de programmer en Java, car c’est un langage que nous connaissons et qu’un langage objet nous paraissait pertinent pour gérer des objets comme des solutions ou des graphes. De plus, Java nous permet d’utiliser les fonctions liées à ses bibliothèques qui sont déjà optimisées. Nous savions donc que si un algorithme s’exécutait dans un temps supérieur à la normale, ce serait de la faute de l’algorithme et non des fonctions Java.

\section{Structures de données}
Pour stocker le graphe en mémoire, nous avons choisi d’utiliser une liste d’adjacence qui est remplie à la lecture du fichier par le programme. Cette liste est ensuite traitée par le programme pour créer un premier partitionnement (stocké dans l’objet GraphePartition), qui est la base de notre programme et sur lequel toutes les méthodes seront appliquées. Cet objet GraphePartition représente un graphe partitionné et contient notamment le numéro de classe attribué à chaque sommet, le nombre de classes prévues et l’évaluation de la solution courante.

\section{Voisinages implémentés}
Nous avons décidé d’implémenter deux voisinages, le Pick’n'Drop et le Swap. Ainsi l’utilisateur pourra choisir entre eux.
    Nous n’avons pas implémenté le voisinage par Sweep car il revient à effectuer plusieurs Swap d’affilée.

\section{Solution initiale}

Pour la solution initiale, chaque sommet du graphe est placé dans l’une des classes aléatoirement. Nous avons implémenté deux fonctions différentes suivant le voisinage utilisé : pour le voisinage Pick'n'Drop, on choisit un écart maximal pour le nombre de sommets par classe. Pour le voisinage Swap, la répartition des sommets dans les classes est totalement aléatoire.

\section{Evaluation}

La fonction d’évaluation se présente en deux étapes.

\begin{enumerate}
\item  Calcul de I1 : La première évaluation est le nombre d’arètes interclasses, cette étape ne sera effectuée qu’une seule fois. L’évaluation sera ensuite mise à jour pour chaque sommet déplacé.

\item Calcul de I2 : La deuxième évaluation applique un malus dépendant de la taille des classes. Elle consiste à calculer l’écart moyen du cardinal des classes (en pourcentage du nombre de sommets), et de le multiplier ensuite par I1 (en ayant au préalable ajouté 100 pour empêcher les multiplication par 0) plus 1. Cette étape est faite à chaque demande d’évaluation.
\end{enumerate}

Exemple : Pour un graphe G de 1000 sommets ayant une solution avec trois classes de taille 320, 335, 345.
Pour 712 arêtes interclasses, la première évaluation sera I1 = 712.
Calculs de l’écart moyen : ((345-335)+(345-320)+(335-320))/3 = 13.33.
En pourcentage cela donne : e =13.33/1000 = 0.013.
L’évaluation finale sera donc : I2 = (100 + I1) * (1+e) = (100 + 712)*1.013 = 822.556.
NB: Pour donner plus ou moins d’influence dans l’équilibre de la taille des classes, nous multiplions par un coefficient a fixé. Ainsi on aura : I2 = (I1 + 100) * (1+e*a)

\section{Lanceur}

Ce module prend en paramètre le graphe initial, le type de voisinage et le nombre de classes désirées. Il implémente une fonction run() qui prend en paramètre le nom d’un algorithme, un nombre de tours n et les arguments de l’algorithme.
Il lance alors n fois l’algorithme en parallèle (avec un système de multi-threading), et indique les résultats de chacun des lancers, l’évaluation moyenne, la meilleure des solutions et son évaluation.

\section{Tests}

Nos tests ont été effectués sur les machines du Cremi, ce sont des machines 4 coeurs.

\newpage

\part{Algorithme exhaustif - Enumération explicite}
\setcounter{section}{0}
\section{Description}
Cet algorithme va examiner toutes les solutions possibles. Nous avons choisi d'effectuer un parcours en profondeur.

\section{Paramètres}
Il n’est donc pas nécessaire de choisir un voisinage. La solution initiale est une solution avec tous les sommets dans la première classe (0).

\section{Tests effectués}

\subsection{Graphe à 5 sommets}

\begin{tabular}{|c|c|c|c|}
	\hline 
	nb de classes & 2 & 3 & 4 \\
	\hline
	temps (ms) & 17 & 28 & 101 \\
	\hline
\end{tabular}

\subsection{Graphe à 10 sommets}

\begin{tabular}{|c|c|c|c|c|}
	\hline 
	nb de classes & 2 & 3 & 4 & 5 \\
	\hline
	temps (s) & 0.113 & 1 & 10 & 75 \\
	\hline
\end{tabular}

\subsection{Graphe à 15 sommets}

\begin{tabular}{|c|c|c |}
	\hline 
	nb de classes & 2 & 3 \\
	\hline
	temps (s) & 0.152 & 60 \\
	\hline
\end{tabular}

\bigskip
Graphe à 20 sommets / 2 classes : 17s

Graphe à 22 sommets / 2 classes : 46s

\section{Résultats}
C'est un algorithme qui devient très rapidement long, mais qui donne toujours la meilleure solution pour les petits graphes.

Il est utilisable quelque soit le nombre de classes jusqu’à 10 sommets et pour 2 classes jusqu’à 22 sommets.

\newpage

\part{Descente de gradient}
\setcounter{section}{0}
\section{Description}
Cet algorithme part d’une solution initiale aléatoire et tourne tant qu’une solution meilleure a été trouvée dans son voisinage. On cherche à chaque tour de boucle la meilleure solution voisine. Si celle-ci est meilleure que la solution courante, elle devient solution courante. Sinon, l’algorithme s’arrête.

\section{Paramètres}
Cet algorithme dépend du type de voisinage de la solution. 

\section{Tests}

\begin{tabular}{|c|c|c|c|c|c|c|}
	\hline 
	nb de classes & nb de Sommets & nb de lancers & tps moyen & tps total & eval min & ecart moyen \\
	\hline
	2 & 20 & 20 & 150 ms & 3 s 17 ms & 140 & 7.5 \\
	\hline
	2 &  50  &  50  &     ms   &    s    ms   &     &     \\
	\hline
	2 &  100  &  100  &     ms   &   s    ms    &     &     \\
	\hline
	2 &  500  &  500  &      ms  &    s    ms   &     &     \\
	\hline
	2 &  1000  &  1000  &    ms    &   s    ms    &     &     \\
	\hline
	\hline
	5 &  20  &  20  &     ms   &   s    ms    &     &     \\
	\hline
	5 &  50  &  50  &     ms   &   s     ms   &     &     \\
	\hline
	5 &  100  & 100   &     ms   &   s    ms    &     &     \\
	\hline
	5 & 500   & 500   &     ms   &   s     ms   &     &     \\
	\hline
	5 &  1000  &  1000  &     ms   &   s    ms    &     &     \\
	\hline
\end{tabular}

\section{Résultats}

Nous avons testé l’algorithme de gradient avec beaucoup plus de lancements que les deux algorithmes suivants (recuit simulé et tabou), car il était beaucoup plus rapide. En effet, il ne cherche pas à sortir des minima.
% A COMPLETER

\newpage

\part{Recuit simulé}
\setcounter{section}{0}
\section{Description}
Cet algorithme est basé sur la physique. On utilise la température comme paramètre. Pour chaque baisse de température, on cherche une solution courante optimale. A la température minimale, la solution trouvée doit être optimale.

\section{Paramètres}
Cet algorithme dépend du voisinage. De plus, nous laissons à l’utilisateur le choix de la température initiale, c’est un double qui doit être supérieure à la température minimale.

\section{Choix d'implémentation}

\paragraph{Taille du problème}
Dans cet algorithme nous utilisons N, la taille du problème. Nous avons décidé de prendre le nombre d’arètes comme taille. Le nombre d’arêtes majore le nombre de sommets car nous sommes sur des graphes simples. Donc le nombre d’arêtes est plus représentatif des problèmes appliqués aux graphes simples.

\paragraph{Solution initiale} Comme pour les autres algorithmes, la solution initiale est aléatoire.

\paragraph{Température initiale} Elle est donnée au choix à l’utilisateur. Celle-ci est un double qui doit être supérieure à la température minimale, $0.1^\circ$ . Sachant que la baisse de température est assez rapide (voir suite) la température doit être assez conséquente, supérieure à $20^\circ$ pour que l’algorithme tourne suffisamment longtemps.

\paragraph{Choix condition 1} Afin de sortir de la boucle, l’algorithme doit répondre à l’une des deux conditions suivantes :
	\begin{itemize}
    \item soit on a atteint la température minimale, fixée à $0.1^\circ$
    \item soit la température a changé 5 fois et la solution courante n’a pas changé.
    \end{itemize}

Nous pensons que ces deux conditions sont importantes car cela permet d'arrêter plus rapidement l'algorithme, et donc d’optimiser les temps d’exécution. Si l’utilisateur choisit une température extrêmement élevée par rapport au problème, la condition sur k permet tout de même une réponse rapide.

\paragraph{Choix condition 2} Afin de sortir de cette deuxième boucle, l’algorithme doit répondre à l’une des trois conditions suivantes :
	\begin{itemize}
	\item soit on a fait N*N tours de boucle
	\item soit on a tiré 10*N solutions dont l’évaluation est plus grande que la solution courante
	\item soit on a accepté 10*N solutions dont l’évaluation est plus grande que la solution courante
	\end{itemize}
Ces trois conditions nous paraissaient nécessaires dans le cas des grands graphes. Dans les petits graphes la boucle s'arrête quasi-systématiquement après accomplissement de la première condition, dans le cas des grands graphes, l’une des deux conditions est prévalente, ce qui est du à la croissance moins rapide de la borne maximale.


\paragraph{Choix de la solution voisine} La solution voisine doit être aléatoire. On effectue simplement un mouvement du voisinage en cours.
\paragraph{Choix de la fonction g} La fonction g est la fonction de chute de la température. Celle-ci est simple : on multiplie la température actuelle par la raison r. Au début de l’algorithme, r est choisie au hasard entre 0.7 et 0.9 pour que l’algorithme de Métropolis puisse accepter suffisamment de solutions supérieures pour pouvoir sortir d’un minimum local. 

\section{Tests effectués}
Voici quelques tests effectués. Afin de les comparer nous utilisons un test témoin, le premier puis nous faisons varier un paramètre à la fois.

\bigskip
Température initiale : $20^\circ$C

Voisinage : PnD

Nombre de classes : 2
\bigskip

\begin{tabular}{|c|c|c|c|c|c|}
	\hline 
	sommets & lancers & tps moyen & tps total & ecart moyen & eval min\\
	\hline
	20 & 20 & 150 ms & 3 s 100 ms & 2 & 140 \\
	\hline
	 50  &  50  &   130  ms   &   6 s  300  ms   &   6.26  &   315  \\
	\hline
	 100  &  75  &   423  ms   &  32 s  &  10   &   1025  \\
	\hline
	 500  &  100  &  2 min 40 s  &  3 min 30  s &  54   &   3635  \\
	\hline
\end{tabular}
\bigskip

\subsection*{Changement du voisinage}

Température initiale : $20^\circ$C

Voisinage : Swap

Nombre de classes : 2
\bigskip

\begin{tabular}{|c|c|c|c|c|c|}
	\hline 
	sommets & lancers & tps moyen & tps total & ecart moyen & eval min\\
	\hline
	20 & 20 & 37 ms & 750 ms & 35 & 140 \\
	\hline
	 50  &  50  &   210  ms   &   10 s  500  ms   &  75   &   301  \\
	\hline
	 100  &  75  & 1 s 150  ms   &  1 min 26 s &  144   &   1003  \\
	\hline
	 500  &  100  & 3 s 800  ms  &  6 min 25  s &   290  &   3482  \\
	\hline
\end{tabular}
\bigskip

\subsection*{Changement de la température}

Température initiale : $40^\circ$C

Voisinage : PnD

Nombre de classes : 2

\bigskip
\begin{tabular}{|c|c|c|c|c|c|}
	\hline 
	sommets & lancers & tps moyen & tps total & ecart moyen & eval min\\
	\hline
	20 & 20 & 153 ms & 3 s 100 ms & 1 & 140 \\
	\hline
	 50  &  50  & 138 ms   &  7  s  &   7  & 315\\
	\hline
	 100  &  75  &   465  ms   &  35 s &   8  &  1028   \\
	\hline
	 500  &  100  &      ms  &    s    ms   &     &     \\
	\hline
\end{tabular}
\bigskip

\subsection*{Changement du nombre de classes}

Température initiale : $20^\circ$C

Nombre de sommets : 50 

Voisinage : PnD
\bigskip

\begin{tabular}{|c|c|c|c|c|}
	\hline 
	nb classes & tps moyen & tps total & ecart moyen & eval min\\
	\hline
	5 & 187 ms & 9 s 400 ms & 5 & 479 \\
	\hline
	10  &  250   ms   &  12  s   600 ms   &  5   &  537   \\
	\hline
	20 &  360   ms   &  18 s  200  ms    &  6   &   562  \\
	\hline
	30  &   300 ms  &  15 s  300  ms   &  33   &    536 \\
	\hline
\end{tabular}

\bigskip

Température initiale : $20^\circ$

Nombre de sommets : 100 

Voisinage : PnD
\bigskip

\begin{tabular}{|c|c|c|c|c|}
	\hline 
	nb classes & tps moyen & tps total & ecart moyen & eval min\\
	\hline
	5 & 245 ms & 18 s 400 ms & 15 & 1655 \\
	\hline
	10  &  332   ms   &  25  s  &  11   &  1874   \\
	\hline
	35  &   1 s 250 ms   & 1 min 35  s &   6  &   2039  \\
	\hline
	50  &   3 s & 3 min  20 s &   16 &   203  \\
	\hline
	75  &   6 s 700 ms & 8 min  21 s  &  17   &  2025   \\
	\hline
\end{tabular}

\bigskip 
(Ce dernier test a été effectué sur un autre ordinateur, c’est pour cela que les vitesses sont plus petites que les témoins)

\section{Résultats}

% A COMPLETER AVEC LA CONCLUSION

\newpage

\part{Algorithme Tabou}
\setcounter{section}{0}
\section{Description}
Cet algorithme est une heuristique qui utilise un tableau de mouvements interdits (ou tabous) pour pouvoir sortir des minima locaux. On stocke les mouvements interdits plutôt que les solutions interdites par souci d’économie de la mémoire.

\section{Paramètres}
Le tableau de mouvements interdits (ou tableau tabou) est un tableau d’objets de type Mouvement. Sa taille est fixée par l’utilisateur à l’appel de l’algorithme.

Un mouvement est un objet qui contient plusieurs champs : deux champs représentant des sommets, un champ représentant une classe et un champ représentant le timestamp associé à ce mouvement. Cette représentation permet de gérer des mouvements de type Pick’n’Drop (en instanciant seulement un des deux sommets et le numéro de la classe) et des mouvements de type swap (en instanciant les champs correspondant aux deux sommets à échanger).
Le timestamp de chaque mouvement, qui correspond à la durée de présence du mouvement dans le tableau des mouvements tabous, est incrémenté à chaque tour de boucle et le mouvement est retiré du tableau quand son timestamp atteint la valeur de la taille du tableau.

\section{Tests effectués}
Pour effectuer les tests, nous avons pris comme témoin un tableau tabou de taille 5 et un partitionnement en deux classes.

\bigskip

Taille du tableau Tabou : 5

Voisinage : PnD

Nombre de classes : 2
\bigskip

\begin{tabular}{|c|c|c|c|c|c|}
	\hline 
	sommets & lancers & tps moyen & tps total & ecart moyen & eval min\\
	\hline
	20 & 20 & 31 ms & 75 ms & 1.2 & 140 \\
	\hline
	 50 & 50 & 49 ms & 283 ms & 7.74 & 291 \\
	\hline
	 100 & 75 & 3 s 27 ms & 4 s 401 ms & 16.49 & 935 \\
	\hline
	 500 & 100 & 10 min 55 s 624 ms & 11 min 6 s 733 ms & 39.78 & 2952 \\
	\hline
\end{tabular}
\bigskip

Changement de la taille du tableau Tabou :

Taille du tableau Tabou : 8

Voisinage : PnD

Nombre de classes : 2
\bigskip

\begin{tabular}{|c|c|c|c|c|c|}
	\hline 
	sommets & lancers & tps moyen & tps total & ecart moyen & eval min\\
	\hline
	20 & 20 & 73 ms & 131 ms & 1.05 & 140 \\
	\hline
	 50  &  50  &   89  ms   &  365  ms   &  8.6   &   291  \\
	\hline
	 100  &  75  &  4 s 89   ms   &  4 s  856  ms    &  13.84   &   937  \\
	\hline
	 500 & 100 & 11 min 4 s 350 ms & 11 min 15 s 518 ms & 73.11 & 2923 \\
	\hline
\end{tabular}
\bigskip

Changement du nombre de classes :

Taille du tableau Tabou : 5

Voisinage : PnD

Nombre de classes : 5
\bigskip

\begin{tabular}{|c|c|c|c|c|c|}
	\hline 
	sommets & lancers & tps moyen & tps total & ecart moyen & eval min\\
	\hline
	20 & 20 & 105 ms & 180 ms & 2.1 & 172 \\
	\hline
	 50  &  50  &   907  ms   &  1  s  262  ms   &   10.5  &   443  \\
	\hline
	 100  &  75  & 22 s 524  ms   &  24 s  351  ms    &  24.84   &   1519  \\
	\hline
	 500  &  100  &     &      &     &     \\
	\hline
\end{tabular}
\bigskip

Changement du voisinage utilisé :

Taille du tableau Tabou : 5

Voisinage : Swap

Nombre de classes : 5
\bigskip

\begin{tabular}{|c|c|c|c|c|c|}
	\hline 
	sommets & lancers & tps moyen & tps total & ecart moyen & eval min\\
	\hline
	20 & 20 & 46 ms & 172  ms & 12 & 206 \\
	\hline
	 50  &  50  &   8 s 401  ms   &  9  s 591   ms   &  82.92   &   336  \\
	\hline
	 100  &  75  & 6 min 58 s 772    ms  & 7 min 8 s 746   ms   &  196.68   &   1092 \\
	\hline
	 500  &  100  &    &   &   &  \\
	\hline
\end{tabular}

\section{Résultats}

En augmentant la taille du tableau Tabou, le temps de calcul augmente mais le pourcentage d'augmentation tend vers zéro avec l'augmentation de la taille du problème :
\begin{itemize}
\item 20 sommets / 20 lancers : 108 \% d'augmentation
\item 50 sommets / 50 lancers : 81 \% d'augmentation
\item 100 sommets / 75 lancers : 35 \% d'augmentation
\item 500 sommets / 100 lancers : 1,3 \% d'augmentation
\end{itemize}
\bigskip

En augmentant le nombre de classes, le temps de calcul moyen augmente fortement :
\begin{itemize}
\item 20 sommets / 20 lancers : 238 \% d'augmentation
\item 50 sommets / 50 lancers : 1751 \% d'augmentation
\item 100 sommets / 75 lancers : 644 \% d'augmentation
\end{itemize}
Ceci est normal, puisque la taille du voisinage augmente aussi considérablement.
\bigskip 

En changeant de voisinage (Swap au lieu de Pick'n'Drop), les temps de calcul moyens augmentent également, car la taille du voisinage est plus importante.


\newpage

\part{Méthode de travail}
\setcounter{section}{0}
\section{Utilisation de git}
Pour travailler sur ce projet, nous avons utilisé le logiciel de gestion de versions Git et sa plateforme d’hébergement web GitHub. Nous avons travaillé en mettant en place des branches de travail, qui étaient ensuite intégrées au code principal. Nous avons également utilisé le système des “issues” de GitHub, qui nous ont permis de lister les tâches à effectuer et donc d’avoir un suivi global du projet.

\part{Conclusion}
\setcounter{section}{0}
		
\end{document}